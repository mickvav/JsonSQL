.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "JsonSQL::Query::Insert 3pm"
.TH JsonSQL::Query::Insert 3pm "2017-07-29" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JsonSQL::Query::Insert \- JsonSQL::Query::Insert object. Stores a Perl representation of a set of INSERT statements created from a JSON string.
.SH "VERSION"
.IX Header "VERSION"
version 0.4
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Use this to generate an \s-1SQL INSERT\s0 statement from a \s-1JSON\s0 string.
.PP
To use this:
.PP
.Vb 1
\&    use JsonSQL::Query::Insert;
\&    
\&    my $jsonString = \*(Aq{
\&        "inserts": [
\&            {
\&                "table": {"table": "table1", "schema": "MySchema"},
\&                "values": [
\&                    {"column": "column1", "value": "value1"},
\&                    {"column": "column2", "value": "value2"}
\&                ],
\&                "returning": [{"column": "column1", "as": "bestcolumn"}, {"column": "column2"}]
\&            },
\&            {
\&                "table": {"table": "table2"},
\&                "values": [
\&                    {"column": "columnA", "value": "valueA"},
\&                    {"column": "columnB", "value": "valueB"}
\&                ]
\&            }
\&        ]
\&    }\*(Aq;
\&    
\&    my $whitelisting_rules = [
\&        { schema => \*(Aq#anySchema\*(Aq, \*(Aqtable1\*(Aq => [ \*(Aqcolumn1\*(Aq, \*(Aqcolumn2\*(Aq ], \*(Aqtable2\*(Aq => [ \*(AqcolumnA\*(Aq, \*(AqcolumnB\*(Aq ] }
\&    ];
\&    
\&    my ( $insertObj, $err ) = JsonSQL::Query::Insert\->new($whitelisting_rules, $jsonString);
\&    if ( $insertObj ) {
\&        my ( $sql, $binds ) = $insertObj\->get_all_inserts;
\&        <...>
\&    } else {
\&        die $err;
\&    }
.Ve
.PP
Now you can go ahead and use \f(CW$sql\fR and \f(CW$binds\fR directly with the \s-1DBI\s0 module to do the query.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a JsonSQL Query module that supports \s-1SQL\s0 generation for batched \s-1INSERT\s0 statements.
.PP
Examples of \s-1INSERT\s0 features supported by this module:
.SS "A single \s-1INSERT\s0 statement (minimum),"
.IX Subsection "A single INSERT statement (minimum),"
.Vb 11
\&    {
\&        "inserts": [
\&            {
\&                "table": {"table": "MyTable"},
\&                "values": [
\&                    {"column": "Animal", "value": "Giraffe"},
\&                    {"column": "Color", "value": "Yellow/Brown"}
\&                ]
\&            }
\&        ]
\&    }
.Ve
.SS "An \s-1INSERT\s0 statement with a \s-1RETURNING\s0 clause,"
.IX Subsection "An INSERT statement with a RETURNING clause,"
.Vb 10
\&    {
\&        "inserts": [
\&            {
\&                "table": {"table": "MyTable"},
\&                "values": [
\&                    {"column": "Animal", "value": "Giraffe"},
\&                    {"column": "Color", "value": "Yellow/Brown"}
\&                ],
\&                "returning": [
\&                    {"column": "animal_id"}
\&                ]
\&            }
\&        ]
\&    }
.Ve
.SS "Multiple \s-1INSERT\s0 statements for batch processing,"
.IX Subsection "Multiple INSERT statements for batch processing,"
.Vb 10
\&    {
\&        "inserts": [
\&            {
\&                "table": {"table": "MyTable"},
\&                "values": [
\&                    {"column": "Animal", "value": "Giraffe"},
\&                    {"column": "Color", "value": "Yellow/Brown"}
\&                ]
\&            },
\&            {
\&                "table": {"table": "MyTable"},
\&                "values": [
\&                    {"column": "Animal", "value": "Elephant"},
\&                    {"column": "Color", "value": "Grey"}
\&                ]
\&            },
\&            {
\&                "table": {"table": "MyTable"},
\&                "values": [
\&                    {"column": "Animal", "value": "Horse"},
\&                    {"column": "Color", "value": "Black"}
\&                ]
\&            }
\&        ]
\&    }
.Ve
.SS "Structure of \s-1INSERT JSON\s0 object:"
.IX Subsection "Structure of INSERT JSON object:"
The top-level property is the \*(L"inserts\*(R" property, which is an array of objects representing each \s-1INSERT.\s0 Each \s-1INSERT\s0 object has the
following properties:
.PP
\fIRequired,\fR
.IX Subsection "Required,"
.ie n .IP "table => { table => ""table1"" }" 4
.el .IP "table => { table => ``table1'' }" 4
.IX Item "table => { table => table1 }"
.Vb 2
\&    Generates: INSERT INTO \*(Aqtable1\*(Aq
\&See L<JsonSQL::Param::Table> for more info.
.Ve
.ie n .IP "values => [ { column => ""scientist"", value = ""Einstein"" }, { column => ""theory"", value = ""Relativity"" } ]" 4
.el .IP "values => [ { column => ``scientist'', value = ``Einstein'' }, { column => ``theory'', value = ``Relativity'' } ]" 4
.IX Item "values => [ { column => scientist, value = Einstein }, { column => theory, value = Relativity } ]"
.Vb 3
\&    Generates (\*(Aqscientist\*(Aq,\*(Aqtheory\*(Aq) VALUES (?,?)
\&        Bind: [\*(AqEinstein\*(Aq,\*(AqRelativity\*(Aq]
\&See L<JsonSQL::Param::InsertValues> for more info.
.Ve
.PP
\fIOptional,\fR
.IX Subsection "Optional,"
.ie n .IP "returning => { column => ""column_id"" }" 4
.el .IP "returning => { column => ``column_id'' }" 4
.IX Item "returning => { column => column_id }"
.Vb 2
\&    Generates: RETURNING \*(Aqcolumn_id\*(Aq;
\&See L<JsonSQL::Param::Insert> for more info.
.Ve
.PP
\fIAdditional Properties,\fR
.IX Subsection "Additional Properties,"
.IP "defaultschema => 'myschema'" 4
.IX Item "defaultschema => 'myschema'"
If you are using \s-1DB\s0 schemas, this property can be used to generate the schema identifier for your queries. Particularly useful for
per-user \s-1DB\s0 schemas.
.PP
See JsonSQL::Schemas::insert to view the restrictions enforced by the \s-1JSON\s0 schema.
.SS "Whitelisting Module"
.IX Subsection "Whitelisting Module"
A set of whitelisting rules is required to successfully use this module to generate \s-1SQL.\s0 See JsonSQL::Validator to learn how this works.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "Constructor new($query_rulesets, $json_query)"
.el .SS "Constructor new($query_rulesets, \f(CW$json_query\fP)"
.IX Subsection "Constructor new($query_rulesets, $json_query)"
Instantiates and returns a new JsonSQL::Query::Insert object.
.PP
.Vb 2
\&    $query_rulesets      => The whitelisting rules to validate the query with.
\&    $json_query          => A stringified JSON object representing the query.
.Ve
.PP
Returns (0, <error message>) on failure.
.ie n .SS "ObjectMethod get_all_inserts \-> ( $sql, $binds )"
.el .SS "ObjectMethod get_all_inserts \-> ( \f(CW$sql\fP, \f(CW$binds\fP )"
.IX Subsection "ObjectMethod get_all_inserts -> ( $sql, $binds )"
Generates the \s-1SQL\s0 statement represented by the object. Returns:
.PP
.Vb 2
\&    $sql            => An arrayref of SQL INSERT strings.
\&    $binds          => An arrayref of arrays of parameterized values to pass with each INSERT query.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Hoefler <bhoefler@draper.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2017 by Chris Hoefler.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
